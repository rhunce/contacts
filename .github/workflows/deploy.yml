name: Deploy Full Stack

on:
  push:
    branches: [ main, master ]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'infra/**'
  workflow_dispatch: # Manual trigger

env:
  NODE_VERSION: '18'
  CDK_DEFAULT_ACCOUNT: ${{ secrets.CDK_DEFAULT_ACCOUNT }}
  CDK_DEFAULT_REGION: ${{ vars.CDK_DEFAULT_REGION }}
  APP_NAME: ${{ vars.APP_NAME }}
  NODE_ENV: ${{ vars.NODE_ENV }}
  ROOT_DOMAIN: ${{ vars.ROOT_DOMAIN }}

jobs:
  deploy-backend:
    runs-on: ubuntu-latest
    outputs:
      alb-url: ${{ steps.deploy.outputs.alb-url }}
      api-url: ${{ steps.deploy.outputs.api-url }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: infra/package-lock.json

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.CDK_DEFAULT_REGION }}

    - name: Install dependencies
      working-directory: ./infra
      run: npm ci --include=dev

    - name: CDK Bootstrap
      working-directory: ./infra
      run: npx cdk bootstrap aws://${{ env.CDK_DEFAULT_ACCOUNT }}/${{ env.CDK_DEFAULT_REGION }}
      continue-on-error: true

    - name: Deploy Backend Stack
      id: deploy
      working-directory: ./infra
      run: |
        npx cdk deploy ${APP_NAME}BackendStack --require-approval never
        ALB_URL=$(aws cloudformation describe-stacks --stack-name ${APP_NAME}BackendStack --query 'Stacks[0].Outputs[?OutputKey==`AlbUrl`].OutputValue' --output text)
        API_URL=$(aws cloudformation describe-stacks --stack-name ${APP_NAME}BackendStack --query 'Stacks[0].Outputs[?OutputKey==`ApiUrl`].OutputValue' --output text)
        echo "alb-url=$ALB_URL" >> $GITHUB_OUTPUT
        echo "api-url=$API_URL" >> $GITHUB_OUTPUT

  deploy-frontend:
    needs: deploy-backend
    runs-on: ubuntu-latest
    outputs:
      frontend-url: ${{ steps.deploy-frontend.outputs.frontend-url }}
      cloudfront-id: ${{ steps.deploy-frontend.outputs.cloudfront-id }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: infra/package-lock.json

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.CDK_DEFAULT_REGION }}

    - name: Install dependencies
      working-directory: ./infra
      run: npm ci --include=dev

    - name: Deploy Frontend Infrastructure
      id: deploy-frontend
      working-directory: ./infra
      run: |
        npx cdk deploy ${APP_NAME}FrontendStack --require-approval never
        FRONTEND_URL=$(aws cloudformation describe-stacks --stack-name ${APP_NAME}FrontendStack --query 'Stacks[0].Outputs[?OutputKey==`FrontendUrl`].OutputValue' --output text)
        CLOUDFRONT_ID=$(aws cloudformation describe-stacks --stack-name ${APP_NAME}FrontendStack --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontDistributionId`].OutputValue' --output text)
        echo "frontend-url=$FRONTEND_URL" >> $GITHUB_OUTPUT
        echo "cloudfront-id=$CLOUDFRONT_ID" >> $GITHUB_OUTPUT

    - name: Setup Node.js for frontend build
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install frontend dependencies
      working-directory: ./frontend
      run: npm ci --include=dev

    - name: Build frontend
      working-directory: ./frontend
      run: |
        export NEXT_PUBLIC_API_URL="${{ needs.deploy-backend.outputs.api-url }}"
        npm run build

    - name: Deploy frontend to S3
      working-directory: ./frontend
      run: |
        BUCKET_NAME=$(aws cloudformation describe-stacks --stack-name ${APP_NAME}FrontendStack --query 'Stacks[0].Outputs[?OutputKey==`FrontendBucketName`].OutputValue' --output text)
        aws s3 sync out/ s3://$BUCKET_NAME --delete

    - name: Invalidate CloudFront cache
      run: aws cloudfront create-invalidation --distribution-id ${{ steps.deploy-frontend.outputs.cloudfront-id }} --paths "/*"

  update-api-cors:
    needs: [deploy-backend, deploy-frontend]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.CDK_DEFAULT_REGION }}

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Update API CORS configuration
        env:
          APP_NAME: ${{ env.APP_NAME }}
          FRONTEND_URL: ${{ needs.deploy-frontend.outputs.frontend-url }}
        run: |
          set -euo pipefail

          STACK_NAME="${APP_NAME}BackendStack"

          # Get ECS cluster and service from CFN resources
          CLUSTER_NAME=$(aws cloudformation list-stack-resources \
            --stack-name "$STACK_NAME" \
            --query 'StackResourceSummaries[?ResourceType==`AWS::ECS::Cluster`].PhysicalResourceId' \
            --output text)

          SERVICE_NAME=$(aws cloudformation list-stack-resources \
            --stack-name "$STACK_NAME" \
            --query 'StackResourceSummaries[?ResourceType==`AWS::ECS::Service`].PhysicalResourceId' \
            --output text)

          if [ -z "$CLUSTER_NAME" ] || [ -z "$SERVICE_NAME" ]; then
            echo "ERROR: Could not find ECS Cluster or Service in stack $STACK_NAME"
            exit 1
          fi

          echo "Cluster: $CLUSTER_NAME"
          echo "Service: $SERVICE_NAME"
          echo "Frontend URL (CORS_ORIGIN): $FRONTEND_URL"

          # Fetch current task definition
          TASK_DEF_ARN=$(aws ecs describe-services --cluster "$CLUSTER_NAME" --services "$SERVICE_NAME" --query 'services[0].taskDefinition' --output text)
          TASK_DEF_JSON=$(aws ecs describe-task-definition --task-definition "$TASK_DEF_ARN" --query 'taskDefinition' --output json)

          # Existing CORS_ORIGIN?
          EXISTING_CORS=$(echo "$TASK_DEF_JSON" | jq -r '.containerDefinitions[0].environment[]? | select(.name=="CORS_ORIGIN") | .value // empty')

          if [ "$EXISTING_CORS" = "$FRONTEND_URL" ]; then
            echo "CORS_ORIGIN already set to $FRONTEND_URL"
            exit 0
          fi

          echo "Updating CORS_ORIGIN -> $FRONTEND_URL"

          # Remove existing CORS_ORIGIN entry if present
          TASK_DEF_NO_CORS=$(echo "$TASK_DEF_JSON" | jq '(.containerDefinitions[0].environment) |= (map(select(.name!="CORS_ORIGIN")))')

          # Add/append new CORS_ORIGIN
          UPDATED_TASK_DEF=$(echo "$TASK_DEF_NO_CORS" | jq --arg ORIGIN "$FRONTEND_URL" '.containerDefinitions[0].environment += [{"name":"CORS_ORIGIN","value":$ORIGIN}]')

          # Keep only accepted fields
          CLEAN_TASK_DEF=$(echo "$UPDATED_TASK_DEF" | jq '{
            family, taskRoleArn, executionRoleArn, networkMode, containerDefinitions,
            volumes, placementConstraints, requiresCompatibilities, cpu, memory
          }')

          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json "$CLEAN_TASK_DEF" --query 'taskDefinition.taskDefinitionArn' --output text)

          aws ecs update-service --cluster "$CLUSTER_NAME" --service "$SERVICE_NAME" --task-definition "$NEW_TASK_DEF_ARN"

          echo "Waiting for service to stabilize..."
          aws ecs wait services-stable --cluster "$CLUSTER_NAME" --services "$SERVICE_NAME"

      - name: Output deployment info
        run: |
          echo "Full stack deployment completed successfully!"
          echo "Frontend URL: ${{ needs.deploy-frontend.outputs.frontend-url }}"
          echo "Backend ALB URL (HTTP redirected): ${{ needs.deploy-backend.outputs.alb-url }}"
          echo "Backend API URL (HTTPS): ${{ needs.deploy-backend.outputs.api-url }}"
